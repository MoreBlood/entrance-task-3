### Общие ответы и исправления:
- Для того чтобы `service-worker` стал обрабатывать запросы за ресурсами приложения
его необходимо перенести в корневую папку проекта, т.к. видимость `worker'`a или его ` scope` и есть его место расположения.
Также из-за это необходимо изменить пути всех связанных ресурсов и объявления `service-worker`'a.
- Для добавления файлов в кэш, необходимо добавить массив перечисления
 ресурсов `ASSETS_TO_CACHE` и метод `cacheAssets()`, выполняющий их кэширование на
 этапе `install` 
 - Для обновления статики, необходимо поменять версию кэша, например `CACHE_VERSION = '1.0.1-fixed'`
### Ответы на вопросы, в файле `service-worker.js`:

* **Вопрос №1**: Зачем нужен этот вызов? `self.skipWaiting()`<br>
><text style="font-size :85%; color :#404040;">Вызов предотвращает ожидание, и  `worker` сразу же начинает свою работу, не дожидаясь завершения работы предыдущего `worker'a`. Типичная ситуация применения - обновление `service-worker'a`<text>
* **№2**: Зачем нужен этот вызов? `self.clients.claim()`<br>
><text style="font-size :85%; color :#404040;">Позволяет начать контролировать страницу `worker'y` без перезагрузки<text>
* **№3**: Для всех ли случаев подойдёт такое построение ключа? `url.origin + url.pathname`<br>
><text style="font-size :85%; color :#404040;">Да, например пользователь будет искать что-то, например `https://yandex.ru/gifs.html?text=котятки`, то для `/assets/blocks.js` ключ будет вида `https://yandex.ru/assets/blocks.js` <text>
* **№4**: Зачем нужна эта цепочка вызовов?<br>
><text style="font-size :85%; color :#404040;">Когда новый `service worker`а становится активным, цепочкой вызовов удаляется кэш предыдущей версии, это выполянется только при условии изменения версии кэша.</text>
* **№5**: Для чего нужно клонирование? `cache.put(cacheKey, response.clone())`<br>
><text style="font-size :85%; color :#404040;">Поток `response` можно прочитать один раз, поэтому `response.clone()` кэшируется, а основной `response` будет оправлен браузеру <text>
